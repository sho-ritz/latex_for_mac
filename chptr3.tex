%/**********************************************************************/
%		第4章：LEDマトリクスのフリッカ周波数差を用いたカメラベース可視光通信方式
%**********************************************************************/
\chapter{LEDマトリクスのフリッカ周波数差を用いたカメラベース可視光通信方式}
\label{lbl_chptr5}


%======================================================================
% 4.1 提案方式の概要
%======================================================================
\section{提案方式の概要}
本節では、LEDマトリクスパネルを用いた可視光通信方式について説明する。
自分が提案する方式は、2つの異なる点滅周波数を用いて同一のデータを並列に送信する方式である。今回のシステムでは、2つの異なる点滅周波数を用いて、バイナリを表現し、それを受信部で復号する方式を採用した。また、今回は4つの領域に分割して、それぞれの領域で異なる点滅周波数を用いて同一のデータを並列に送信する方式を採用した。
これにより、単一領域で送信する方式と比較して4倍のデータ送信速度を実現することを目指した。

今回の実験では、送信システムのみの実験を行った。


%======================================================================
% 4.2 送信側ハードウェア・ソフトウェア構成
%======================================================================
\section{可視光通信のロジック}

本節では、具体的な可視光通信のロジックについて説明する。具体的には点灯パターンの設計と分割領域における点灯パターンの設計について説明する。


\subsection{点灯パターンの設計}
今回のシステムでは、2つの点滅周波数を用いて、バイナリを表現し、それを受信部で復号する方式を採用した。

当初は、領域を4つに分割することを中心に検討していたため、全体を高い方の周波数で駆動させ、低い方の周波数領域は1/2になるように、2回に1回点灯させるようにする方式を検討していた。しかし、そのやり方では、duty比が高い方の周波数の時は100\%、低い方の周波数の時は50\%となってしまい、人間の視覚に違和感を与えるため、この方式は採用しなかった。（以下、この方式を「旧法」と呼ぶ）
それを考慮して新たに点灯パターンを設計した。具体的には、高い方の周波数の時は50\%、低い方の周波数の時は100\%となるようにする方式を採用した。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\linewidth]{assets/flicker_pattern.png}
  \caption{提案方式におけるフリッカパターン}
  \label{fig:flicker_pattern}
\end{figure}

このパターンを用いることで、高い周波数の時は50\%、低い周波数の時は100\%となり、人間の視覚に違和感を与えないようにすることができる。

\subsection{バイナリ変換の方法}
実際に点灯パターンから受信側でバイナリとして変換する方法について説明する。



また、当初は60Hzと120Hzで実験を行ったが、人間の目から見て若干のちらつきが生まれた。

人間の視覚は、臨界フリッカ融合周波数（critical flicker fusion）という周波数があり、その周波数以上はフリッカを感じなくなり、連続点灯に見えるという性質がある。条件によるが、およそ60~100Hzと言われているため、60Hzは連続点灯に見える可能性が高い。

\subsection{分割領域における点灯パターンの設計}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\linewidth]{assets/split_matrix.png}
  \caption{4分割LEDマトリクスの走査制御}
  \label{fig:split_matrix}
\end{figure}


\subsection{Cコード実装とシンボル列の構成}

% 本小節では，Raspberry Pi上で動作するC言語による実装構成を説明する．
% フレームカウンタに基づいて各領域に割り当てられたbit値を参照し，
% preamble，sync語，payloadからなるシンボル列を生成してパネルに出力する処理の流れを記述する．
% コード全体を細かく示すのではなく，主要なデータ構造と処理ステップの概要を書く．


%======================================================================
% 4.3 バランス符号による色味差低減
%======================================================================
\section{バランス符号による色味差低減}

本節では，人間の視覚における色味差を抑えるために導入したバランス符号について述べる．

\subsection{naive方式で生じる色味差の問題}

本小節では，論理1を常時点灯（100\%デューティ），論理0を半分点灯（50\%デューティ）とした
単純なフリッカ表現では，人間の目には白色と黄色が混在したような色味差が生じる。

\subsection{平均デューティ50\%のバランス符号設計}

本小節では，bit=1を1010…，bit=0を1100…とするような時間パターンを用いて，
どちらのbitでも周期内の点灯回数を揃える「バランス符号」の設計方針を述べる．
120Hzフレーム列に対して8フレームを1周期としたときの具体的な波形イメージを言葉で説明し，
人間の視覚では平均輝度が揃って見える一方で，カメラ側では周期パターンの違いから
bitを識別できる。


%======================================================================
% 4.4 シンボル設計と同期語
%======================================================================
\section{シンボル設計と同期語}

本節では，シンボル系列の構成と同期取得のための同期語設計について述べる．

\subsection{preambleシンボル列による同期取得}

% 本小節では，通信開始時に全領域同一パターンのシンボル列（preamble）を挿入し，
% 受信側がフリッカパターンの存在と大まかなフレーム境界を検出する手順を記述する．

\subsection{同期語とシンボル境界推定}

% 本小節では，1010/0101などの特定パターンを用いた同期語（sync word）を設計し，
% 受信フレーム列との相関を取ることでシンボル境界と位相を推定する方法を述べる．
% どの程度の長さの同期語を用いれば，誤検出を抑えつつ十分な同期精度が得られるかを議論する．

\subsection{理論スループットの算出}

% 本小節では，1シンボル4bit，シンボル長8フレーム，ベースフレーム周波数120Hzといった
% パラメータを用いて，理論的な通信スループット（bps）を計算する．
% また，人間の視覚に違和感を与えない範囲でこれらのパラメータをどこまで変更できるかについても
% 簡単に考察する．


%======================================================================
% 4.5 受信アルゴリズム
%======================================================================
\section{受信アルゴリズム}

本節では，スマートフォンカメラで撮影されたフレーム列からbit列を復号するアルゴリズムについて述べる．

\subsection{フレーム列からの時系列データ生成}

% 本小節では，60fps程度で取得した動画から，各フレームにおける4領域の平均輝度を算出し，
% 時間方向に並べた輝度系列を生成する処理について説明する．
% 領域分割の方法や，輝度値の正規化など，前処理の概要を記述する．

\subsection{bitパターンとの類似度評価と位相推定}

% 本小節では，送信側のシンボル長（120Hz 8フレーム）と受信側のフレームレート
% （60fps）との対応を踏まえ，4サンプルまたは8サンプルの窓を用いて
% 1010および1100といった理論パターンとの類似度を評価する方法を説明する．
% 位相ずれに対して頑健にするために，複数の位相候補を試し，
% 最もスコアが高い組み合わせをbit=0/1として採用する考え方を述べる．

\subsection{復号フロー全体}

% 本小節では，preamble検出 → 同期語検出 → payload復号という
% 復号フロー全体のステップを整理する．
% 各ステップでどのような入力・出力があり，誤検出に対してどのような対策が必要かを簡潔にまとめる．


%======================================================================
% 4.6 実装コードと最適化
%======================================================================
\section{実装コードと最適化}

% 本節では，実装段階で発生した問題と，それに対する最適化の工夫について述べる．
% 特に，フレーム境界付近で一瞬黄ばむ現象が観測された場合について，
% preambleとの切替タイミングやOE制御のタイミングずれが原因となりうることを考察する．
% また，Raspberry Pi上でのスロット時間管理や割り込み制御，CPU負荷の削減といった
% 実装上の工夫を概要レベルでまとめる．


%======================================================================
% 4.7 小括
%======================================================================
\section{小括}

% 本節では，本章で提案したフリッカ周波数差を用いるカメラベース可視光通信方式の内容をまとめる．
% 4領域並列によるシンボル設計，平均輝度を揃えたバランス符号，
% スマートフォンカメラを想定した受信アルゴリズムという三つの要素を整理し，
% 既存のLED表示装置に対して人間の視覚的な違和感を抑えつつ情報埋め込みを行うという
% 目標に対してどの程度達成できたかを簡潔に振り返る．
% 次章では，本方式の表示品質・通信性能を定量的に評価し，課題と今後の展望を議論する．

